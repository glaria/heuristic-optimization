# -*- coding: utf-8 -*-
"""
Tabu search implementation
"""


from Shared import berlin52,tourCost, constructInitialSolution
import random, time



''' Retuns the newSol in newSols with the lowest cost ''' 
def locateBestNewSol(newSols):
    newSols.sort(key = lambda c: c["cost"])
    bestNewSol = newSols[0]
    return bestNewSol 


''' Returns True if aPermutation contains an edge in tabuList; returns False otherwise '''         
def isTabu(aPermutation, tabuList):
    size = len(aPermutation)
    for index, node in enumerate(aPermutation):
        if index == size - 1:
            nextNode = aPermutation[0]
        else:
            nextNode = aPermutation[index + 1]
        edge = [node, nextNode]
        if edge in tabuList:
            return True
    
    return False    

def stochasticTwoOptWithEdges(perm):
    result = perm[:] # make a copy
    size = len(result)
    # select indices of two random points in the tour
    p1, p2 = random.randrange(0,size), random.randrange(0,size)
    # do this so as not to overshoot tour boundaries
    exclude = set([p1])
    
    if p1 == 0:
        exclude.add(size-1)
    else:
        exclude.add(p1-1)
    if p1 == size-1:
        exclude.add(0)
    else:
        exclude.add(p1+1)                       
    while p2 in exclude:
        p2 = random.randrange(0,size)

    # to ensure we always have p1<p2        
    if p2<p1:
        p1, p2 = p2, p1
        
    # now reverse the tour segment between p1 and p2   
    result[p1:p2] = reversed(result[p1:p2])
    
    return result, [[perm[p1-1], perm[p1]], [perm[p2-1], perm[p2]]]

def generateNewSol(baseSol, bestSol, tabuList):
    newPermutation, edges, newSol = None, None, {}
    #save the 2 edges deleted in stoch2opt in the new sol
    while newPermutation == None or isTabu(newPermutation, tabuList):
        newPermutation, edges = stochasticTwoOptWithEdges(baseSol["permutation"])
        
        #aspiration criterion: always accept a better solution generated
        if tourCost(newPermutation) < bestSol['cost']:
            break
    newSol["permutation"] = newPermutation
    newSol["cost"] = tourCost(newSol["permutation"])
    newSol["edges"] = edges
    return newSol


''' ALGORITHM FRAMEWORK '''
algorithmName = "TABU SEARCH"
print("Best Sol by " + algorithmName + "...")
# Problem configuration
inputsTSP = berlin52 # TSP instance
#inputsTSP = [ [-2,0], [-1,1], [0,2], [1,1], [2,0], [1,-1], [0,-2], [-1,-1] ]
maxNewSols = 40 # max number of newSols to generate
maxIterations = 5000 # iterations in the main loop
maxEdgesInTabuList = 10 # permutation edges in the tabu list
k = 5 # multiplier for the demon-based acceptance criterion

# a sol as a dictionary including the permutation of nodes, its associated cost, and two edges if
# sol has been generated in a 2-opt local search
bestSol = {}
# construct an initial random sol (permutation of nodes, each one defined by two coordinates)
bestSol["permutation"] = constructInitialSolution(inputsTSP) # generates a random permutation
bestSol["cost"] = tourCost(bestSol["permutation"]) # computes its associated cost
bestSol["edges"] = None # this sol has not been generated by a 2-opt local search
baseSol = bestSol

credit = 0 # credit for the demon-based acceptance criterion
tabuList = [] # list of tabu edges 

start = time.time() # start clock
while maxIterations > 0:
    # Generates newSols in the neighborhood of bestSol by using stocahstic 2-opt; the two edges employed
    # in the 2-opt local search are added to the tabu list, so they cannot appear in future newSols
    # Then, chooses the best newSol in newSols
    newSols = []
    for index in range(0, maxNewSols):
        # Generate a newSol that does not uses any tabu edge and add it to a list of newSols
        # In the first interation, the tabu list is empty
        newSol = generateNewSol(baseSol, bestSol, tabuList)
        newSols.append(newSol)
    
    # Locate the bestNewSol among the newSols
    bestNewSol = locateBestNewSol(newSols)
    # Compare with current baseSol and update if necessary
    # Worse solutions are accepted as the baseSol according to an acceptable
    # worsening margin (using delta and credit variables)
    delta = bestNewSol["cost"] - baseSol["cost"]
    if delta <= 0:
        credit = -1 * delta
        baseSol = bestNewSol
        
        if bestNewSol["cost"] < bestSol["cost"]:
            bestSol = bestNewSol
            print('it:', maxIterations, 'cost: %.2f' % bestSol["cost"])
        
            # Add the two edges in bestNewSol that were deleted by the 2-opt to the tabu list
            for edge in bestNewSol["edges"]:
                tabuList.append(edge)
                if len(tabuList) > maxEdgesInTabuList:
                    del tabuList[0] 

    else: # acceptance criterion to avoid local minimum
        if delta <= k * credit:
            credit = 0
            baseSol = bestNewSol
        
                   
    maxIterations -= 1


# Stop clock and return outputs    
stop = time.time()
#stop = time.process_time()
print("BestCost = %.2f ; Elapsed = %.2fs " % (bestSol["cost"], stop - start))
print("BestSol = %s " % bestSol["permutation"])


        