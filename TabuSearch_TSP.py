'''
Author: Sai Panyam & Angel A. Juan
Timestamp: 2021.06.08

TABU SEARCH is a Metaheuristic and a Global Optimization algorithm.
The strategy is to constrain an embedded heuristic from returning to recently visited areas of the search space (cycling).
It maintains a short term memory of recent moves and prevents future moves from undoing those changes. This strategy can be extended
by having intermediate term memory structures to bias moves towards promising areas (intensification), as well as long term memory
structures that promote diversity.

Code for a TSP, based on 'Clever Algorithms' by Jason Brownlee.
A solution for the TSP is a permutation of the nodes (order in which they are visited)
'''

from Shared import constructInitialSolution, tourCost, stochasticTwoOptWithEdges, berlin52
import time


''' Retuns the newSol in newSols with the lowest cost ''' 
def locateBestNewSol(newSols):
    newSols.sort(key = lambda c: c["cost"])
    bestNewSol = newSols[0]
    return bestNewSol 


''' Returns True if aPermutation contains an edge in tabuList; returns False otherwise '''         
def isTabu(aPermutation, tabuList):
    size = len(aPermutation)
    for index, node in enumerate(aPermutation):
        if index == size - 1:
            nextNode = aPermutation[0]
        else:
            nextNode = aPermutation[index + 1]
        edge = [node, nextNode]
        if edge in tabuList:
            return True
    
    return False    


''' Returns a newSol after applying a 2-Opt operator, it also returns the two edges involved ''' 
def generateNewSol(baseSol, bestSol, tabuList):
    newPermutation, edges, newSol = None, None, {}
    # Generates a new permutation that does not include any edge from the tabu list
    while newPermutation == None or isTabu(newPermutation, tabuList):
        # In the newSol, save the two edges deleted during the stochastic 2-opt
        # this two edges will be included in the tabu list, so that they cannot be 
        # included in future newPermutations
        newPermutation, edges = stochasticTwoOptWithEdges(baseSol["permutation"])
        # aspiration criterion: if the move generates a solution with a better cost than
        # the best one, always accept it (regardless of if it is tabu or not)
        if tourCost(newPermutation) < bestSol['cost']:
            break
        
    newSol["permutation"] = newPermutation
    newSol["cost"] = tourCost(newSol["permutation"])
    newSol["edges"] = edges
    return newSol



''' ALGORITHM FRAMEWORK '''
algorithmName = "TABU SEARCH"
print("Best Sol by " + algorithmName + "...")
# Problem configuration
inputsTSP = berlin52 # TSP instance
#inputsTSP = [ [-2,0], [-1,1], [0,2], [1,1], [2,0], [1,-1], [0,-2], [-1,-1] ]
maxNewSols = 40 # max number of newSols to generate
maxIterations = 5000 # iterations in the main loop
maxEdgesInTabuList = 10 # permutation edges in the tabu list
k = 5 # multiplier for the demon-based acceptance criterion

# a sol as a dictionary including the permutation of nodes, its associated cost, and two edges if
# sol has been generated in a 2-opt local search
bestSol = {}
# construct an initial random sol (permutation of nodes, each one defined by two coordinates)
bestSol["permutation"] = constructInitialSolution(inputsTSP) # generates a random permutation
bestSol["cost"] = tourCost(bestSol["permutation"]) # computes its associated cost
bestSol["edges"] = None # this sol has not been generated by a 2-opt local search
baseSol = bestSol

credit = 0 # credit for the demon-based acceptance criterion
tabuList = [] # list of tabu edges 

start = time.time() # start clock
while maxIterations > 0:
    # Generates newSols in the neighborhood of bestSol by using stocahstic 2-opt; the two edges employed
    # in the 2-opt local search are added to the tabu list, so they cannot appear in future newSols
    # Then, chooses the best newSol in newSols
    newSols = []
    for index in range(0, maxNewSols):
        # Generate a newSol that does not uses any tabu edge and add it to a list of newSols
        # In the first interation, the tabu list is empty
        newSol = generateNewSol(baseSol, bestSol, tabuList)
        newSols.append(newSol)
    
    # Locate the bestNewSol among the newSols
    bestNewSol = locateBestNewSol(newSols)
    # Compare with current baseSol and update if necessary
    # Worse solutions are accepted as the baseSol according to an acceptable
    # worsening margin (using delta and credit variables)
    delta = bestNewSol["cost"] - baseSol["cost"]
    if delta <= 0:
        credit = -1 * delta
        baseSol = bestNewSol
        
        if bestNewSol["cost"] < bestSol["cost"]:
            bestSol = bestNewSol
            print('it:', maxIterations, 'cost: %.2f' % bestSol["cost"])
        
            # Add the two edges in bestNewSol that were deleted by the 2-opt to the tabu list
            for edge in bestNewSol["edges"]:
                tabuList.append(edge)
                if len(tabuList) > maxEdgesInTabuList:
                    del tabuList[0] 

    else: # acceptance criterion to avoid local minimum
        if delta <= k * credit:
            credit = 0
            baseSol = bestNewSol
        
                   
    maxIterations -= 1


# Stop clock and return outputs    
stop = time.time()
#stop = time.process_time()
print("BestCost = %.2f ; Elapsed = %.2fs " % (bestSol["cost"], stop - start))
print("BestSol = %s " % bestSol["permutation"])


